---
title: "CIC Project: Pre-processing RNA-Seq Data and Performing QC"
author: "Stephen Lee"
date: '`r format(Sys.time(), "%B %d, %Y")`'
output: github_document
---

## Table of Contents

----

[**Overview**](#overview)    
[**Using Make**](#make)    
  - [Setting up directory](#dir)    
  - [Processing BAM files](#bams)    
  - [Generate Count Matrices using SUBREAD](#counts)    
  
[**Pre-processing and QC in R**](#QC)    
	- [Load libraries](#setup)    
	- [Import files](#import)   
	- [Sequencing Metrics](#metrics)    
	- [Data Transformation](#transform)    
	- [Between sample distribution](#sample_dist)   
	- [Expression Heatmap](#heatmap)    
	- [Distance Matrix](#dist_mat)     


## **Overview** <a name="overview"></a>

----

**What are the consequences of *CIC* loss on global gene expression in a wildtype and neomorphic IDH1 background?**  

> To address this question, transcriptomes from isogenic *CIC* wildtype and knockout cell lines were obtained through the GSC ribodepletion RNA-seq protocol (3 replicates each). This was performed on immortalized normal human astrocytes expressing wildtype IDH1 (**NHA**) or IDH1-R132H (**F8**) and on an oligodendroglioma derived cell line possessing the 1p/19q co-deletion as well as IDH1-R132H (**L54**)

### **Experimental Model**
> Our experimental models consists of normal human astrocytes that were immortalized using independent retroviral infections of E6, E7 and hTERT (http://cancerres.aacrjournals.org/content/61/13/4956) and a cell line derived from a treatment naive anaplastic oligodendroglioma possessing 1p/19q co-del and IDH1-R132H. *CIC*-KO cell lines were generated from these parental lines using a CRISPR-guide targeting the first commonly shared exon between the two *CIC* isoforms. 

Cell Line  | CIC Status  | IDH1 Status  | 1p/19q status
---------- | ----------- | ------------ | --------------
NHA        | WT          | WT           | intact
NHAA2      | KO          | WT           | intact
NHAH9      | KO          | WT           | intact
F8         | WT          | R132H        | intact
F8A2       | KO          | R132H        | intact
F8E10      | KO          | R132H        | intact
L54        | WT          | R132H        | codeleted
N4D6       | KO          | R132H        | codeleted
N8F4       | KO          | R132H        | codeleted

### **GSC Files**

----

A file listing the full path to GSC BAM files for each library can be found here:
```/projects/marralab_cic_prj/rna_seq/libs.tsv```

Sample     | Passage | Library ID 
---------- | ------- | ----------
NHA_rep1   | 8       | A80061
NHA_rep2   | 10      | A80055
NHA_rep3   | 12      | A80058
NHAA2_rep1 | 8       | A80062
NHAA2_rep2 | 10      | A80056
NHAA2_rep3 | 12      | A80059
NHAH9_rep1 | 8       | A80063
NHAH9_rep2 | 10      | A80057
NHAH9_rep3 | 12      | A80060
F8_rep1    | 16      | A85151
F8_rep2    | 17      | A85154
F8_rep3    | 20      | A85157
F8A2_rep1  | 16      | A85152
F8A2_rep2  | 17      | A85155
F8A2_rep3  | 20      | A85158
F8E10_rep1 | 16      | A85153
F8E10_rep2 | 17      | A85156
F8E10_rep3 | 20      | A85159
L54_rep1   | 3       | A92847
L54_rep2   | 4       | A92850
L54_rep3   | 4       | A92853
N4D6_rep1  | 3       | A92848
N4D6_rep2  | 4       | A92851
N4D6_rep3  | 4       | A92854
N4D6_rep1  | 3       | A92849
N4D6_rep2  | 4       | A92852
N4D6_rep3  | 4       | A92855

Additional bioinformatics analysis files regarding isoform quantification (generated by the GSC) can be found here:

**NHA:**  

- Coverage:    
```/projects/wtsspipeline/analysis/<lib_name>/coverage/hg19a_jg-e75o_bwa-mem-0.7.6a-sb/ensembl_homo_sapiens_core_75_37/production_v1.1/```

- Isoform:    
```/projects/wtsspipeline/analysis/<lib_name>/isoform_v1.0```

**F8:**  

- Coverage:    
```/projects/wtsspipeline/analysis/<lib_name>/coverage/hg19a_jg-e75o_bwa-mem-0.7.6a-sb/ensembl_homo_sapiens_core_75_37/production_v1.1/```

- Isoform:    
```/projects/wtsspipeline/analysis/<lib_name>/isoform_v1.0```

## **Using Make** <a name="make"></a>

----

### **Directory structure** <a name="dir"></a>

All files regarding RNA-seq for this project is located in ```/projects/marralab_cic_prj/rna_seq```. The directory is structured such that Makefiles recipes are easy to write. A directory is made for each sample; in Make we can loop through these directories to generate files with identical names. Here, we create the subdirectories **bam/** and **rna/** in each sample directory and symbolically link the GSC BAM files.

```
libs = $(shell cat libs.tsv | grep "/" | cut -f 1)
lib_locs = $(shell cat libs.tsv | awk '{print$$1"__"$$2}')

setupdir = $(foreach lib, ${libs}, $(lib)/bam)
dir : ${setupdir}

# create directory structure
%/bam :
       	mkdir $*; mkdir $*/bam; mkdir $*/rna;

# import gsc bam files
get_bams = $(foreach lib_loc, ${lib_locs}, $(lib_loc)/bam/gsc.bam)
getbams : ${get_bams}

%/bam/gsc.bam :
        lib=$$(echo $* | awk '{ gsub("__.*", ""); print }'); \
        loc=$$(echo $* | awk '{ gsub(".*__", ""); print }'); \
        ln -s $${loc} $${lib}/bam/gsc.bam
```

### **Processing BAM files** <a name="bams"></a>

Here, we obtain general information on each BAM file using *samtools flagstat* which will be used for intial QC purposes. We also filter out unmapped reads, sort and index the BAM files to generate our own hard copy.

```
filter_sort = $(foreach lib, ${libs}, $(lib)/bam/gsc.sorted.bam)
flagstats = $(foreach lib, ${libs}, $(lib)/bam/flagstat.txt)

sortbams : ${filter_sort}
flags : ${flagstats}

# filter unmapped reads; sort and index
%/bam/gsc.sorted.bam :
        samtools view -bF 4 $*/bam/gsc.bam > $*/bam/tmp.bam; \
        samtools sort $*/bam/tmp.bam $*/bam/gsc.sorted; \
        samtools index $*/bam/gsc.sorted.bam \
        $*/bam/gsc.sorted.bam.bai; rm $*/bam/tmp.bam

# flagstat
%/bam/flagstat.txt :
        samtools flagstat $*/bam/gsc.bam > $@
```

### **Generate count matrices using featureCounts** <a name="counts"></a>

Next, we use SUBREAD featureCounts to generate count matrices which we can then use for differential expression analysis in R.

```
subread = /projects/jtopham_prj/installs/subread-1.4.6-p5-source/bin
gtf_file = /projects/marralab_cic_prj/shared_objects/Homo_sapiens.GRCh37.75.gtf

run_counts = $(foreach lib, ${libs}, $(lib)/rna/counts.tsv)
counts : ${run_counts}

%/rna/counts.tsv :
        cd $*/rna; \
        ${subread}/featureCounts -pC -T 20 -t 'gene' -a ${gtf_file} -o counts.tsv \
        ${wd}/$*/bam/gsc.sorted.bam
```

----

## **Pre-processing and QC in R** <a name=QC"></a>

----

### **load librarires**  <a name="setup"></a>
```{r, message=FALSE, warning=FALSE}
library(knitr)
library(tidyverse)
library(stringr)
library(plyr)
library(cowplot)
library(data.table)
library(matrixStats)
library(pheatmap)
library(RColorBrewer)

select <- dplyr::select
map <- purrr::map
```

### **Import Count Matrices** <a name="import"></a>
```
setwd("/projects/marralab_cic_prj/rna_seq")
read_counts <- function(tsv) {
	count <- read.delim(tsv, comment.char = "#", header = T, sep = '\t', 
											col.names = c("ensembl_id", "chr", "start", "end", "strand", "length", str_split(tsv, "/", simplify = T)[1]))
	
	return(count)
}

get_counts <- function(cell_line) {
	counts <- str_subset(dir(), cell_line) %>% 
		str_c("/rna/counts.tsv") %>% 
		map(read_counts) %>% 
		join_all(by = c("ensembl_id", "chr", "start", "end", "strand", "length")) %>% 
		column_to_rownames("ensembl_id") %>% 
		dplyr::select(-c(chr, start, end, strand, length))
		
	return(counts)
}

all_counts <- get_counts("rep")
saveRDS(all_counts, "R_objects/all_counts.rds")
```

```{r}
wd <- "/projects/marralab_cic_prj/rna_seq/"
all_counts <- readRDS(str_c(wd, "R_objects/all_counts.rds"))

all_counts %>% head() %>% kable()
str(all_counts)
```

We can see that there are genes with a count of 0 in all samples, since these are essentially useless in our downstream analyses, we can remove these non-expressed genes to reduce processing time.
```{r}
all_counts_keep <- all_counts[rowSums(all_counts) > 0, ]
```
> `r nrow(all_counts) - nrow(all_counts_keep)` genes were not detected in any samples.

### **Sequencing Metrics** <a name="metrics"></a>

An important quality metric for any sequencing experiment is the total number of reads and the proportion of these reads that were mapped to the reference genome. We can look at these metrics from the output generated by *samtools flagstat*.
```
read_flagstats <- function(flagstats) {
	files <- read.delim(flagstats, sep = '\t', header = F, stringsAsFactors = F) %>% 
		mutate(lib = str_subset(str_split(flagstats, "/", simplify = T), "rep")) %>% 
		group_by(lib) %>% 
		mutate(total = as.integer(str_replace(first(V1), " .*", "")),
					 mapped = as.integer(str_replace(nth(V1, 3), " .*", "")),
					 perc = as.numeric(str_replace(str_replace(nth(V1, 3), ".* \\(", ""), "%:.*", "")),
					 qc_fail = as.integer(str_replace(str_replace(first(V1), ".*[0-9] [+] ", ""), " in.*", "")),
					 dupe = as.integer(str_replace(nth(V1, 2), " .*", ""))) %>% 
		select(-V1) %>% 
		unique() %>%
		rowwise() %>%
		mutate(dupe_perc = dupe / mapped * 100) %>% 
		separate(lib, c("cell_line", "rep"), sep = "_")
	
	return(files)
}

flagstats <- str_subset(dir(), "rep") %>% 
	str_c("/bam/flagstat.txt") %>% 
	map(read_flagstats) %>% 
	bind_rows()

saveRDS(flagstats, "R_objects/RNA-seq_flagstats.rds")
```

```{r, fig.align='center'}
flagstats <- readRDS(str_c(wd, "R_objects/RNA-seq_flagstats.rds")) %>% 
  unite(col = sample, cell_line, rep, sep = "_")

ggplot(flagstats, aes(reorder(sample, total), total)) +
       geom_col() +
       labs(x = NULL, y = "Total # Reads") +
       theme(axis.text.x = element_text(angle = 90))

ggplot(flagstats, aes(sample, perc)) +
       geom_col() +
       labs(x = NULL, y = "% Mapped Reads") +
       theme(axis.text.x = element_text(angle = 90))
```

> The total number of reads for our samples range from ~150-250M reads, well above the ([ENCODE recommendation of >30M](https://genome.ucsc.edu/encode/protocols/dataStandards/ENCODE_RNAseq_Standards_V1.0.pdf)) and almost all reads were mapped to the hg19 reference genome, indicating high quality.


### **Data Transformation** <a name="transform"></a>
It is helpful to use transformed data for exploratory and visualization purposes. We can see here that the distribution of counts is highly skewed to the left, i.e. a large proportion of genes are expressed at very low levels.
```{r, fig.align='center'}
ggplot(all_counts, aes(x = NHA_rep1)) + geom_histogram(binwidth = 2000)
```

In order to gain meaningful insight from our data, normalization is required. To approximately normalize this distribution, we apply a logarithmic transformation. 
```{r, fig.align='center'}
all_logcounts <- log2(all_counts_keep + 1)

ggplot(all_logcounts, aes(x = NHA_rep1)) + geom_histogram(colour = "white", binwidth = 0.6)
```

By visualizing the logcount distributions in all samples, we can get an idea of how similar samples are to each other.

```{r, message=FALSE, fig.align='center'}
all_logcounts_m <- all_logcounts %>%
  as.data.frame() %>% 
	melt(variable.name = "samples") %>% 
	separate(samples, c("cell", "rep"))

ggplot(all_logcounts_m, aes(cell, value, fill = cell)) + geom_violin() +
  xlab("") + ylab(expression(log[2](count + 1))) +
  facet_wrap(~rep) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 90))
```

> As we can see all samples have very comparable distributions.

### **Expression Heatmap** <a name="heatmap"></a>

Expression heatmaps are useful visualizations that highlight the similarities (and dissimilarities) of gene expression profiles between samples. Clustering on gene expression patterns group samples with similar profiles together, hence, we expect L54 cell lines and NHA cell lines to group separately. Given that CIC and IDH1 affect transcription, we also expect that cell lines will be grouped according to the status of these two genes. Here we use the top 1000 most variable genes in our dataset for clustering and generating our heatmap. 

```{r, fig.align='center'}
select <- head(order(-rowVars(all_logcounts %>% as.matrix())), 1000)

anno_df <- data.frame(CIC = rep(c(rep("WT", 3), rep("KO", 6)), 3), 
                      IDH1 = c(rep("R132H", 18), rep("WT", 9)), 
                      chr_1p19q = c(rep("intact", 9), rep("codeleted", 9 ), rep("intact", 9)),
                      row.names = colnames(all_logcounts))

anno_colors = list(CIC = c("#14AA7B", "#85BFAD"), IDH1 = c("#ED6904", "#FFC69E"), chr_1p19q = c("#843E8E", "#BF84ED"))
names(anno_colors$CIC) <- unique(anno_df$CIC)
names(anno_colors$IDH1) <- unique(anno_df$IDH1)
names(anno_colors$chr_1p19q) <- unique(anno_df$chr_1p19q)

top_1000_variable_genes <- all_logcounts[select, ]

pheatmap(top_1000_variable_genes, 
         col = colorRampPalette(c("seagreen3", "white", "tomato"))(100), 
         scale = "row",
         cluster_rows = T, 
         cluster_cols = T, 
         show_rownames = F, 
         annotation_col = anno_df, 
         annotation_colors = anno_colors)
```

> Indeed, the expression profiles of the top 1000 most variable genes cluster samples according their molecular features. We can clearly see that the biggest divergence in transcriptomes lies between L54 and NHA cell lines.

### **Distance Matrix** <a name="dist_mat"></a>

Another way to explore how similar samples are in relation to each other is to look at the sample-to-sample distance matrix. Here, the euclidean distance is calculated between samples and hierarchical clustering is performed to group similar samples together. 

```{r, message=FALSE, fig.align='center'}
plot_sample_dists <- function(logcounts) {
	sample_dists <- dist(t(logcounts))
	sample_dist_mat <- as.matrix(sample_dists)
	colnames(sample_dists) <- NULL
	colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)
	p <- pheatmap(sample_dist_mat, 
	              clustering_distance_rows = sample_dists, 
	              clustering_distance_cols = sample_dists, 
	              col = colors) +
		   theme(plot.margin = margin(1, 1, 1, 1, "cm"))
	
	return(p)
}

plot_sample_dists(all_logcounts)
```

> Like in the heatmap, L54 and NHA cell lines group into their own clusters. We can also note that within the L54 cell lines one CIC-WT replicate grouped with the CIC-KO cells.

### **Principal Components** <a name="pca"></a>

Principal component analysis (PCA) is a method for identifying key features or variables in high-dimensional datasets. In this scenario, we use it as a quality assurance tool to check whether the first two principal components (i.e. the two biggest drivers of variation in the data) cluster samples based on CIC and IDH1 status.

```{r, warning=FALSE, fig.align='center'}
anno_df$CIC <- factor(anno_df$CIC, levels = c("WT", "KO"))
anno_df$IDH1 <- factor(anno_df$IDH1, levels = c("WT", "R132H"))
anno_df$chr_1p19q <- factor(anno_df$IDH1, levels = c("intact", "codeleted"))

library(ggfortify)
autoplot(prcomp(t(all_logcounts)), 
         data = anno_df, 
         colour = "CIC", 
         shape = "IDH1", 
         size = "chr_1p19q")
```

> We can see that the different cell line types provide the biggest source of variability in our dataset. Again, we can see that one CIC-WT sample is grouping with the CIC-KO samples within the L54 cell line, hence we will keep an eye on this one. Otherwise, all of the QC analyses indicate high quality RNA-seq data - now we are ready to proceed into differential expression and other analyses.

